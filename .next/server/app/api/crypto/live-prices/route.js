"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/crypto/live-prices/route";
exports.ids = ["app/api/crypto/live-prices/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcrypto%2Flive-prices%2Froute&page=%2Fapi%2Fcrypto%2Flive-prices%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcrypto%2Flive-prices%2Froute.ts&appDir=C%3A%5CUsers%5CAdmin%5CDesktop%5CZerokost%5CCryptopppp%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CAdmin%5CDesktop%5CZerokost%5CCryptopppp&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcrypto%2Flive-prices%2Froute&page=%2Fapi%2Fcrypto%2Flive-prices%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcrypto%2Flive-prices%2Froute.ts&appDir=C%3A%5CUsers%5CAdmin%5CDesktop%5CZerokost%5CCryptopppp%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CAdmin%5CDesktop%5CZerokost%5CCryptopppp&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_Admin_Desktop_Zerokost_Cryptopppp_app_api_crypto_live_prices_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/crypto/live-prices/route.ts */ \"(rsc)/./app/api/crypto/live-prices/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/crypto/live-prices/route\",\n        pathname: \"/api/crypto/live-prices\",\n        filename: \"route\",\n        bundlePath: \"app/api/crypto/live-prices/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\Admin\\\\Desktop\\\\Zerokost\\\\Cryptopppp\\\\app\\\\api\\\\crypto\\\\live-prices\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_Admin_Desktop_Zerokost_Cryptopppp_app_api_crypto_live_prices_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/crypto/live-prices/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZjcnlwdG8lMkZsaXZlLXByaWNlcyUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGY3J5cHRvJTJGbGl2ZS1wcmljZXMlMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZjcnlwdG8lMkZsaXZlLXByaWNlcyUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNBZG1pbiU1Q0Rlc2t0b3AlNUNaZXJva29zdCU1Q0NyeXB0b3BwcHAlNUNhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPUMlM0ElNUNVc2VycyU1Q0FkbWluJTVDRGVza3RvcCU1Q1plcm9rb3N0JTVDQ3J5cHRvcHBwcCZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDd0M7QUFDckg7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Lz9jZGRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIkM6XFxcXFVzZXJzXFxcXEFkbWluXFxcXERlc2t0b3BcXFxcWmVyb2tvc3RcXFxcQ3J5cHRvcHBwcFxcXFxhcHBcXFxcYXBpXFxcXGNyeXB0b1xcXFxsaXZlLXByaWNlc1xcXFxyb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvY3J5cHRvL2xpdmUtcHJpY2VzL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvY3J5cHRvL2xpdmUtcHJpY2VzXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9jcnlwdG8vbGl2ZS1wcmljZXMvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJDOlxcXFxVc2Vyc1xcXFxBZG1pblxcXFxEZXNrdG9wXFxcXFplcm9rb3N0XFxcXENyeXB0b3BwcHBcXFxcYXBwXFxcXGFwaVxcXFxjcnlwdG9cXFxcbGl2ZS1wcmljZXNcXFxccm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL2NyeXB0by9saXZlLXByaWNlcy9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcrypto%2Flive-prices%2Froute&page=%2Fapi%2Fcrypto%2Flive-prices%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcrypto%2Flive-prices%2Froute.ts&appDir=C%3A%5CUsers%5CAdmin%5CDesktop%5CZerokost%5CCryptopppp%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CAdmin%5CDesktop%5CZerokost%5CCryptopppp&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/crypto/live-prices/route.ts":
/*!*********************************************!*\
  !*** ./app/api/crypto/live-prices/route.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_binance_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/binance-api */ \"(rsc)/./lib/binance-api.ts\");\n\n\nasync function GET() {\n    try {\n        // Fetch live crypto prices from Binance API\n        const cryptoPrices = await _lib_binance_api__WEBPACK_IMPORTED_MODULE_1__.binanceAPI.getCryptoPrices();\n        // Format the response to match the expected structure\n        const livePrices = {};\n        // Process each cryptocurrency\n        cryptoPrices.forEach((crypto)=>{\n            livePrices[crypto.symbol] = {\n                usd: crypto.price_usd,\n                usd_24h_change: crypto.change_24h\n            };\n        });\n        // If no prices were returned, use fallback data\n        if (Object.keys(livePrices).length === 0) {\n            console.warn(\"No crypto prices returned from API, using fallback data\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                BTC: {\n                    usd: 121854.72,\n                    usd_24h_change: 1.5\n                },\n                ETH: {\n                    usd: 3800.00,\n                    usd_24h_change: -0.5\n                },\n                SOL: {\n                    usd: 170.00,\n                    usd_24h_change: 2.3\n                },\n                DOGE: {\n                    usd: 0.16,\n                    usd_24h_change: -3.2\n                }\n            });\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(livePrices);\n    } catch (error) {\n        console.error(\"Error fetching live crypto prices:\", error);\n        // Return fallback data in case of error\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            BTC: {\n                usd: 121854.72,\n                usd_24h_change: 1.5\n            },\n            ETH: {\n                usd: 3800.00,\n                usd_24h_change: -0.5\n            },\n            SOL: {\n                usd: 170.00,\n                usd_24h_change: 2.3\n            },\n            DOGE: {\n                usd: 0.16,\n                usd_24h_change: -3.2\n            }\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL2NyeXB0by9saXZlLXByaWNlcy9yb3V0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMkM7QUFDSTtBQUV4QyxlQUFlRTtJQUNwQixJQUFJO1FBQ0YsNENBQTRDO1FBQzVDLE1BQU1DLGVBQWUsTUFBTUYsd0RBQVVBLENBQUNHLGVBQWU7UUFFckQsc0RBQXNEO1FBQ3RELE1BQU1DLGFBQXNFLENBQUM7UUFFN0UsOEJBQThCO1FBQzlCRixhQUFhRyxPQUFPLENBQUNDLENBQUFBO1lBQ25CRixVQUFVLENBQUNFLE9BQU9DLE1BQU0sQ0FBQyxHQUFHO2dCQUMxQkMsS0FBS0YsT0FBT0csU0FBUztnQkFDckJDLGdCQUFnQkosT0FBT0ssVUFBVTtZQUNuQztRQUNGO1FBRUEsZ0RBQWdEO1FBQ2hELElBQUlDLE9BQU9DLElBQUksQ0FBQ1QsWUFBWVUsTUFBTSxLQUFLLEdBQUc7WUFDeENDLFFBQVFDLElBQUksQ0FBQztZQUNiLE9BQU9qQixxREFBWUEsQ0FBQ2tCLElBQUksQ0FBQztnQkFDdkJDLEtBQUs7b0JBQUVWLEtBQUs7b0JBQVdFLGdCQUFnQjtnQkFBSTtnQkFDM0NTLEtBQUs7b0JBQUVYLEtBQUs7b0JBQVNFLGdCQUFnQixDQUFDO2dCQUFJO2dCQUMxQ1UsS0FBSztvQkFBRVosS0FBSztvQkFBUUUsZ0JBQWdCO2dCQUFJO2dCQUN4Q1csTUFBTTtvQkFBRWIsS0FBSztvQkFBTUUsZ0JBQWdCLENBQUM7Z0JBQUk7WUFDMUM7UUFDRjtRQUVBLE9BQU9YLHFEQUFZQSxDQUFDa0IsSUFBSSxDQUFDYjtJQUMzQixFQUFFLE9BQU9rQixPQUFPO1FBQ2RQLFFBQVFPLEtBQUssQ0FBQyxzQ0FBc0NBO1FBRXBELHdDQUF3QztRQUN4QyxPQUFPdkIscURBQVlBLENBQUNrQixJQUFJLENBQUM7WUFDdkJDLEtBQUs7Z0JBQUVWLEtBQUs7Z0JBQVdFLGdCQUFnQjtZQUFJO1lBQzNDUyxLQUFLO2dCQUFFWCxLQUFLO2dCQUFTRSxnQkFBZ0IsQ0FBQztZQUFJO1lBQzFDVSxLQUFLO2dCQUFFWixLQUFLO2dCQUFRRSxnQkFBZ0I7WUFBSTtZQUN4Q1csTUFBTTtnQkFBRWIsS0FBSztnQkFBTUUsZ0JBQWdCLENBQUM7WUFBSTtRQUMxQztJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vYXBwL2FwaS9jcnlwdG8vbGl2ZS1wcmljZXMvcm91dGUudHM/OGIwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBiaW5hbmNlQVBJIH0gZnJvbSAnQC9saWIvYmluYW5jZS1hcGknO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKCkge1xuICB0cnkge1xuICAgIC8vIEZldGNoIGxpdmUgY3J5cHRvIHByaWNlcyBmcm9tIEJpbmFuY2UgQVBJXG4gICAgY29uc3QgY3J5cHRvUHJpY2VzID0gYXdhaXQgYmluYW5jZUFQSS5nZXRDcnlwdG9QcmljZXMoKTtcbiAgICBcbiAgICAvLyBGb3JtYXQgdGhlIHJlc3BvbnNlIHRvIG1hdGNoIHRoZSBleHBlY3RlZCBzdHJ1Y3R1cmVcbiAgICBjb25zdCBsaXZlUHJpY2VzOiBSZWNvcmQ8c3RyaW5nLCB7IHVzZDogbnVtYmVyLCB1c2RfMjRoX2NoYW5nZTogbnVtYmVyIH0+ID0ge307XG4gICAgXG4gICAgLy8gUHJvY2VzcyBlYWNoIGNyeXB0b2N1cnJlbmN5XG4gICAgY3J5cHRvUHJpY2VzLmZvckVhY2goY3J5cHRvID0+IHtcbiAgICAgIGxpdmVQcmljZXNbY3J5cHRvLnN5bWJvbF0gPSB7XG4gICAgICAgIHVzZDogY3J5cHRvLnByaWNlX3VzZCxcbiAgICAgICAgdXNkXzI0aF9jaGFuZ2U6IGNyeXB0by5jaGFuZ2VfMjRoXG4gICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIC8vIElmIG5vIHByaWNlcyB3ZXJlIHJldHVybmVkLCB1c2UgZmFsbGJhY2sgZGF0YVxuICAgIGlmIChPYmplY3Qua2V5cyhsaXZlUHJpY2VzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gY3J5cHRvIHByaWNlcyByZXR1cm5lZCBmcm9tIEFQSSwgdXNpbmcgZmFsbGJhY2sgZGF0YScpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgQlRDOiB7IHVzZDogMTIxODU0LjcyLCB1c2RfMjRoX2NoYW5nZTogMS41IH0sXG4gICAgICAgIEVUSDogeyB1c2Q6IDM4MDAuMDAsIHVzZF8yNGhfY2hhbmdlOiAtMC41IH0sXG4gICAgICAgIFNPTDogeyB1c2Q6IDE3MC4wMCwgdXNkXzI0aF9jaGFuZ2U6IDIuMyB9LFxuICAgICAgICBET0dFOiB7IHVzZDogMC4xNiwgdXNkXzI0aF9jaGFuZ2U6IC0zLjIgfSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24obGl2ZVByaWNlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbGl2ZSBjcnlwdG8gcHJpY2VzOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBSZXR1cm4gZmFsbGJhY2sgZGF0YSBpbiBjYXNlIG9mIGVycm9yXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIEJUQzogeyB1c2Q6IDEyMTg1NC43MiwgdXNkXzI0aF9jaGFuZ2U6IDEuNSB9LFxuICAgICAgRVRIOiB7IHVzZDogMzgwMC4wMCwgdXNkXzI0aF9jaGFuZ2U6IC0wLjUgfSxcbiAgICAgIFNPTDogeyB1c2Q6IDE3MC4wMCwgdXNkXzI0aF9jaGFuZ2U6IDIuMyB9LFxuICAgICAgRE9HRTogeyB1c2Q6IDAuMTYsIHVzZF8yNGhfY2hhbmdlOiAtMy4yIH0sXG4gICAgfSk7XG4gIH1cbn0iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiYmluYW5jZUFQSSIsIkdFVCIsImNyeXB0b1ByaWNlcyIsImdldENyeXB0b1ByaWNlcyIsImxpdmVQcmljZXMiLCJmb3JFYWNoIiwiY3J5cHRvIiwic3ltYm9sIiwidXNkIiwicHJpY2VfdXNkIiwidXNkXzI0aF9jaGFuZ2UiLCJjaGFuZ2VfMjRoIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImNvbnNvbGUiLCJ3YXJuIiwianNvbiIsIkJUQyIsIkVUSCIsIlNPTCIsIkRPR0UiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./app/api/crypto/live-prices/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/binance-api.ts":
/*!****************************!*\
  !*** ./lib/binance-api.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinanceAPI: () => (/* binding */ BinanceAPI),\n/* harmony export */   binanceAPI: () => (/* binding */ binanceAPI)\n/* harmony export */ });\nclass BinanceAPI {\n    constructor(){\n        this.priceCache = null;\n        this.cacheTimeout = 60000 // 1 minute cache\n        ;\n        this.lastRequestTime = 0;\n        this.minRequestInterval = 2000 // 2 seconds between requests\n        ;\n        this.apiKey = process.env.BINANCE_API_KEY || \"\";\n        this.secretKey = process.env.BINANCE_API_SECRET || \"\";\n        this.baseURL = \"https://api.binance.com\";\n        // Log API key status for debugging\n        console.log(\"Binance API Key status:\", this.apiKey ? \"Present\" : \"Missing\");\n        // Don't throw error, use fallback instead\n        if (!this.apiKey) {\n            console.warn(\"Binance API key not set in environment variables. Using fallback data.\");\n        }\n    }\n    async createSignature(queryString) {\n        // Use Node.js crypto for HMAC SHA256\n        const crypto = await Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ \"crypto\", 23));\n        return crypto.createHmac(\"sha256\", this.secretKey).update(queryString).digest(\"hex\");\n    }\n    getHeaders(includeAuth = false) {\n        const headers = {\n            \"Content-Type\": \"application/json\"\n        };\n        if (includeAuth) {\n            headers[\"X-MBX-APIKEY\"] = this.apiKey;\n        }\n        return headers;\n    }\n    // Rate limiting helper\n    async waitForRateLimit() {\n        const now = Date.now();\n        const timeSinceLastRequest = now - this.lastRequestTime;\n        if (timeSinceLastRequest < this.minRequestInterval) {\n            const waitTime = this.minRequestInterval - timeSinceLastRequest;\n            console.log(`Rate limiting: waiting ${waitTime}ms`);\n            await new Promise((resolve)=>setTimeout(resolve, waitTime));\n        }\n        this.lastRequestTime = Date.now();\n    }\n    // Check if cached data is still valid\n    isCacheValid() {\n        if (!this.priceCache) return false;\n        const now = Date.now();\n        return now - this.priceCache.timestamp < this.cacheTimeout;\n    }\n    // Get live crypto prices with caching and rate limiting\n    async getCryptoPrices() {\n        // Return cached data if still valid\n        if (this.isCacheValid()) {\n            console.log(\"Returning cached price data\");\n            return this.priceCache.data;\n        }\n        // If API key is missing, go directly to alternative source\n        if (!this.apiKey) {\n            console.log(\"No Binance API key available, using alternative source\");\n            return await this.getAlternativePrices();\n        }\n        try {\n            // First try Binance\n            const symbols = [\n                \"BTCUSDT\",\n                \"ETHUSDT\",\n                \"SOLUSDT\",\n                \"DOGEUSDT\"\n            ];\n            console.log(\"Fetching prices from Binance API...\");\n            const response = await fetch(`${this.baseURL}/api/v3/ticker/price`, {\n                headers: this.getHeaders(true) // Include API key in headers\n            });\n            console.log(\"Binance API response status:\", response.status);\n            if (response.status === 451 || response.status === 401) {\n                console.log(\"Binance API restricted or unauthorized, using alternative source\");\n                return await this.getAlternativePrices();\n            }\n            if (!response.ok) {\n                console.error(`Binance API error: ${response.status}`);\n                return await this.getAlternativePrices();\n            }\n            const allPrices = await response.json();\n            console.log(\"Received prices from Binance:\", allPrices.length);\n            // Filter for our supported cryptos and convert to our format\n            const cryptoPrices = symbols.map((symbol)=>{\n                const price = allPrices.find((p)=>p.symbol === symbol);\n                const baseAsset = symbol.replace(\"USDT\", \"\");\n                if (!price) return null;\n                const usdPrice = parseFloat(price.price);\n                const inrPrice = usdPrice * 83.5 // USD to INR conversion\n                ;\n                return {\n                    symbol: baseAsset,\n                    name: this.getCryptoName(baseAsset),\n                    price_usd: usdPrice,\n                    price_inr: inrPrice,\n                    change_24h: 0,\n                    icon: this.getCryptoIcon(baseAsset),\n                    lastUpdated: new Date().toISOString(),\n                    source: \"binance\"\n                };\n            }).filter(Boolean);\n            // Cache the result\n            this.priceCache = {\n                data: cryptoPrices,\n                timestamp: Date.now(),\n                source: \"binance\"\n            };\n            return cryptoPrices;\n        } catch (error) {\n            console.error(\"Error fetching Binance prices:\", error);\n            // Try alternative API\n            return await this.getAlternativePrices();\n        }\n    }\n    // Alternative price source with rate limiting and better error handling\n    async getAlternativePrices() {\n        try {\n            // Apply rate limiting\n            await this.waitForRateLimit();\n            const coinIds = \"bitcoin,ethereum,tether,solana,dogecoin\";\n            const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coinIds}&vs_currencies=usd,inr&include_24hr_change=true`, {\n                headers: {\n                    \"Accept\": \"application/json\",\n                    \"User-Agent\": \"CryptoPaymentGateway/1.0\"\n                }\n            });\n            if (response.status === 429) {\n                console.log(\"CoinGecko API rate limited, using cached or fallback data\");\n                // If we have cached data, return it even if expired\n                if (this.priceCache) {\n                    console.log(\"Returning expired cached data due to rate limit\");\n                    return this.priceCache.data;\n                }\n                // Otherwise use fallback\n                return this.getFallbackPrices();\n            }\n            if (!response.ok) {\n                throw new Error(`CoinGecko API error: ${response.status}`);\n            }\n            const data = await response.json();\n            const cryptoPrices = [\n                {\n                    symbol: \"BTC\",\n                    name: \"Bitcoin\",\n                    price_usd: data.bitcoin?.usd || 42000,\n                    price_inr: data.bitcoin?.inr || 3507000,\n                    change_24h: data.bitcoin?.usd_24h_change || 0,\n                    icon: \"₿\",\n                    lastUpdated: new Date().toISOString(),\n                    source: \"coingecko\"\n                },\n                {\n                    symbol: \"ETH\",\n                    name: \"Ethereum\",\n                    price_usd: data.ethereum?.usd || 3200,\n                    price_inr: data.ethereum?.inr || 267200,\n                    change_24h: data.ethereum?.usd_24h_change || 0,\n                    icon: \"Ξ\",\n                    lastUpdated: new Date().toISOString(),\n                    source: \"coingecko\"\n                },\n                {\n                    symbol: \"USDT\",\n                    name: \"Tether\",\n                    price_usd: data.tether?.usd || 1.0,\n                    price_inr: data.tether?.inr || 83.5,\n                    change_24h: data.tether?.usd_24h_change || 0,\n                    icon: \"₮\",\n                    lastUpdated: new Date().toISOString(),\n                    source: \"coingecko\"\n                },\n                {\n                    symbol: \"SOL\",\n                    name: \"Solana\",\n                    price_usd: data.solana?.usd || 170.0,\n                    price_inr: data.solana?.inr || 14195.0,\n                    change_24h: data.solana?.usd_24h_change || 0,\n                    icon: \"S\",\n                    lastUpdated: new Date().toISOString(),\n                    source: \"coingecko\"\n                },\n                {\n                    symbol: \"DOGE\",\n                    name: \"Dogecoin\",\n                    price_usd: data.dogecoin?.usd || 0.16,\n                    price_inr: data.dogecoin?.inr || 13.36,\n                    change_24h: data.dogecoin?.usd_24h_change || 0,\n                    icon: \"D\",\n                    lastUpdated: new Date().toISOString(),\n                    source: \"coingecko\"\n                }\n            ];\n            // Cache the result\n            this.priceCache = {\n                data: cryptoPrices,\n                timestamp: Date.now(),\n                source: \"coingecko\"\n            };\n            return cryptoPrices;\n        } catch (error) {\n            console.error(\"Error fetching alternative prices:\", error);\n            // If we have cached data, return it even if expired\n            if (this.priceCache) {\n                console.log(\"Returning expired cached data due to API error\");\n                return this.priceCache.data.map((item)=>({\n                        ...item,\n                        source: \"cached\"\n                    }));\n            }\n            // Final fallback to mock data with current timestamp\n            return this.getFallbackPrices();\n        }\n    }\n    // Get 24hr price change statistics with proper error handling\n    async get24hrStats() {\n        try {\n            const symbols = [\n                \"BTCUSDT\",\n                \"ETHUSDT\",\n                \"SOLUSDT\",\n                \"DOGEUSDT\"\n            ];\n            const promises = symbols.map((symbol)=>fetch(`${this.baseURL}/api/v3/ticker/24hr?symbol=${symbol}`, {\n                    headers: this.getHeaders()\n                }).then((response)=>{\n                    if (response.status === 451) {\n                        throw new Error(\"API restricted\");\n                    }\n                    if (!response.ok) {\n                        throw new Error(`HTTP ${response.status}`);\n                    }\n                    return response.json();\n                }).catch((error)=>{\n                    console.log(`Failed to fetch 24hr stats for ${symbol}:`, error.message);\n                    return null;\n                }));\n            const responses = await Promise.all(promises);\n            // Filter out null responses and process valid ones\n            const stats = responses.filter((response)=>response !== null && response.symbol).map((stat)=>({\n                    symbol: stat.symbol.replace(\"USDT\", \"\"),\n                    priceChange: parseFloat(stat.priceChange || \"0\"),\n                    priceChangePercent: parseFloat(stat.priceChangePercent || \"0\"),\n                    lastPrice: parseFloat(stat.lastPrice || \"0\"),\n                    volume: parseFloat(stat.volume || \"0\")\n                }));\n            return stats;\n        } catch (error) {\n            console.error(\"Error fetching 24hr stats:\", error);\n            return [];\n        }\n    }\n    // Get account balances with fallback to mock data\n    /*\n  async getWalletBalances(): Promise<any> {\n    try {\n      const timestamp = Date.now()\n      const queryString = `timestamp=${timestamp}`\n      const signature = await this.createSignature(queryString)\n      \n      const response = await fetch(\n        `${this.baseURL}/api/v3/account?${queryString}&signature=${signature}`,\n        {\n          headers: this.getHeaders(true)\n        }\n      )\n      \n      if (response.status === 451) {\n        console.log('Binance API restricted for wallet balances, using mock data')\n        return this.getMockWalletBalances()\n      }\n      \n      if (!response.ok) {\n        throw new Error(`Binance API error: ${response.status}`)\n      }\n      \n      const accountInfo: BinanceAccountInfo = await response.json()\n      \n      // Filter and format balances\n      const relevantAssets = ['BTC', 'ETH', 'USDT', 'USDC', 'BNB']\n      const balances: Record<string, number> = {}\n      \n      accountInfo.balances.forEach(balance => {\n        if (relevantAssets.includes(balance.asset)) {\n          const total = parseFloat(balance.free) + parseFloat(balance.locked)\n          if (total > 0) {\n            balances[balance.asset] = total\n          }\n        }\n      })\n      \n      return balances\n    } catch (error) {\n      console.error('Error fetching wallet balances:', error)\n      return this.getMockWalletBalances()\n    }\n  }\n  */ // Mock wallet balances for demo purposes\n    getMockWalletBalances() {\n        return {\n            BTC: 0.15432,\n            ETH: 2.8765,\n            USDT: 1250.50,\n            USDC: 500.00,\n            BNB: 12.345,\n            SOL: 25.75,\n            DOGE: 5000.00\n        };\n    }\n    // Convert fiat to crypto amount\n    async convertFiatToCrypto(fiatAmount, fiatCurrency, cryptoSymbol) {\n        try {\n            const prices = await this.getCryptoPrices();\n            const crypto = prices.find((p)=>p.symbol === cryptoSymbol);\n            if (!crypto) return 0;\n            let cryptoPrice = 0;\n            if (fiatCurrency === \"USD\") {\n                cryptoPrice = crypto.price_usd;\n            } else if (fiatCurrency === \"INR\") {\n                cryptoPrice = crypto.price_inr;\n            } else if (fiatCurrency === \"EUR\") {\n                cryptoPrice = crypto.price_usd * 0.85;\n            } else if (fiatCurrency === \"GBP\") {\n                cryptoPrice = crypto.price_usd * 0.75;\n            }\n            return fiatAmount / cryptoPrice;\n        } catch (error) {\n            console.error(\"Error converting fiat to crypto:\", error);\n            return 0;\n        }\n    }\n    // Convert crypto to fiat amount\n    async convertCryptoToFiat(cryptoAmount, cryptoSymbol, fiatCurrency) {\n        try {\n            const prices = await this.getCryptoPrices();\n            const crypto = prices.find((p)=>p.symbol === cryptoSymbol);\n            if (!crypto) return 0;\n            let cryptoPrice = 0;\n            if (fiatCurrency === \"USD\") {\n                cryptoPrice = crypto.price_usd;\n            } else if (fiatCurrency === \"INR\") {\n                cryptoPrice = crypto.price_inr;\n            } else if (fiatCurrency === \"EUR\") {\n                cryptoPrice = crypto.price_usd * 0.85;\n            } else if (fiatCurrency === \"GBP\") {\n                cryptoPrice = crypto.price_usd * 0.75;\n            }\n            return cryptoAmount * cryptoPrice;\n        } catch (error) {\n            console.error(\"Error converting crypto to fiat:\", error);\n            return 0;\n        }\n    }\n    // Generate crypto address (mock - in production use proper wallet generation)\n    generateCryptoAddress(symbol) {\n        const prefixes = {\n            BTC: \"1\",\n            ETH: \"0x\",\n            USDT: \"0x\",\n            USDC: \"0x\",\n            BNB: \"bnb\",\n            SOL: \"sol\",\n            DOGE: \"D\"\n        };\n        const prefix = prefixes[symbol] || \"0x\";\n        const randomHex = Math.random().toString(16).substring(2, 34);\n        return prefix + randomHex;\n    }\n    // Simulate on-chain transfer (in production, use proper blockchain integration)\n    async simulateTransfer(fromAddress, toAddress, amount, symbol) {\n        // Simulate network delay\n        await new Promise((resolve)=>setTimeout(resolve, 2000));\n        // Generate transaction hash\n        const txHash = \"0x\" + Math.random().toString(16).substring(2, 66);\n        console.log(`Simulated ${symbol} transfer:`);\n        console.log(`From: ${fromAddress}`);\n        console.log(`To: ${toAddress}`);\n        console.log(`Amount: ${amount} ${symbol}`);\n        console.log(`TX Hash: ${txHash}`);\n        return txHash;\n    }\n    getCryptoName(symbol) {\n        const names = {\n            BTC: \"Bitcoin\",\n            ETH: \"Ethereum\",\n            USDT: \"Tether\",\n            USDC: \"USD Coin\",\n            BNB: \"Binance Coin\",\n            SOL: \"Solana\",\n            DOGE: \"Dogecoin\"\n        };\n        return names[symbol] || symbol;\n    }\n    getCryptoIcon(symbol) {\n        const icons = {\n            BTC: \"₿\",\n            ETH: \"Ξ\",\n            USDT: \"₮\",\n            USDC: \"$\",\n            BNB: \"B\",\n            SOL: \"S\",\n            DOGE: \"D\"\n        };\n        return icons[symbol] || \"₿\";\n    }\n    // Enhanced fallback prices with realistic variations\n    getFallbackPrices() {\n        // Add some realistic price variations\n        const btcBase = 42000;\n        const ethBase = 3200;\n        const usdtBase = 1.0;\n        const solBase = 170.0;\n        const dogeBase = 0.16;\n        const variation = ()=>(Math.random() - 0.5) * 0.02 // ±1% variation\n        ;\n        return [\n            {\n                symbol: \"BTC\",\n                name: \"Bitcoin\",\n                price_usd: btcBase * (1 + variation()),\n                price_inr: btcBase * 83.5 * (1 + variation()),\n                change_24h: (Math.random() - 0.5) * 10,\n                icon: \"₿\",\n                lastUpdated: new Date().toISOString(),\n                source: \"fallback\"\n            },\n            {\n                symbol: \"ETH\",\n                name: \"Ethereum\",\n                price_usd: ethBase * (1 + variation()),\n                price_inr: ethBase * 83.5 * (1 + variation()),\n                change_24h: (Math.random() - 0.5) * 8,\n                icon: \"Ξ\",\n                lastUpdated: new Date().toISOString(),\n                source: \"fallback\"\n            },\n            {\n                symbol: \"USDT\",\n                name: \"Tether\",\n                price_usd: usdtBase * (1 + variation() * 0.1),\n                price_inr: usdtBase * 83.5 * (1 + variation() * 0.1),\n                change_24h: (Math.random() - 0.5) * 0.5,\n                icon: \"₮\",\n                lastUpdated: new Date().toISOString(),\n                source: \"fallback\"\n            },\n            {\n                symbol: \"SOL\",\n                name: \"Solana\",\n                price_usd: solBase * (1 + variation()),\n                price_inr: solBase * 83.5 * (1 + variation()),\n                change_24h: (Math.random() - 0.5) * 9,\n                icon: \"S\",\n                lastUpdated: new Date().toISOString(),\n                source: \"fallback\"\n            },\n            {\n                symbol: \"DOGE\",\n                name: \"Dogecoin\",\n                price_usd: dogeBase * (1 + variation()),\n                price_inr: dogeBase * 83.5 * (1 + variation()),\n                change_24h: (Math.random() - 0.5) * 12,\n                icon: \"D\",\n                lastUpdated: new Date().toISOString(),\n                source: \"fallback\"\n            }\n        ];\n    }\n    // Clear cache manually if needed\n    clearCache() {\n        this.priceCache = null;\n        console.log(\"Price cache cleared\");\n    }\n    // Get cache status\n    getCacheStatus() {\n        if (!this.priceCache) {\n            return {\n                cached: false,\n                age: 0,\n                source: \"none\"\n            };\n        }\n        const age = Date.now() - this.priceCache.timestamp;\n        return {\n            cached: true,\n            age,\n            source: this.priceCache.source\n        };\n    }\n}\nconst binanceAPI = new BinanceAPI();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q1JDO1lBQ0FwRSxRQUFRLElBQUksQ0FBQ2pFLFVBQVUsQ0FBQ2lFLE1BQU07UUFDaEM7SUFDRjtBQUNGO0FBRU8sTUFBTXFFLGFBQWEsSUFBSXhJLGFBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS12MC1wcm9qZWN0Ly4vbGliL2JpbmFuY2UtYXBpLnRzPzhhNjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIEJpbmFuY2VUaWNrZXJQcmljZSB7XG4gIHN5bWJvbDogc3RyaW5nXG4gIHByaWNlOiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIEJpbmFuY2VFeGNoYW5nZUluZm8ge1xuICBzeW1ib2xzOiB7XG4gICAgc3ltYm9sOiBzdHJpbmdcbiAgICBzdGF0dXM6IHN0cmluZ1xuICAgIGJhc2VBc3NldDogc3RyaW5nXG4gICAgcXVvdGVBc3NldDogc3RyaW5nXG4gIH1bXVxufVxuXG5pbnRlcmZhY2UgQmluYW5jZUFjY291bnRJbmZvIHtcbiAgYmFsYW5jZXM6IHtcbiAgICBhc3NldDogc3RyaW5nXG4gICAgZnJlZTogc3RyaW5nXG4gICAgbG9ja2VkOiBzdHJpbmdcbiAgfVtdXG59XG5cbmludGVyZmFjZSBDYWNoZWRQcmljZURhdGEge1xuICBkYXRhOiBhbnlbXVxuICB0aW1lc3RhbXA6IG51bWJlclxuICBzb3VyY2U6IHN0cmluZ1xufVxuXG5leHBvcnQgY2xhc3MgQmluYW5jZUFQSSB7XG4gIHByaXZhdGUgYXBpS2V5OiBzdHJpbmdcbiAgcHJpdmF0ZSBzZWNyZXRLZXk6IHN0cmluZ1xuICBwcml2YXRlIGJhc2VVUkw6IHN0cmluZ1xuICBwcml2YXRlIHByaWNlQ2FjaGU6IENhY2hlZFByaWNlRGF0YSB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgY2FjaGVUaW1lb3V0OiBudW1iZXIgPSA2MDAwMCAvLyAxIG1pbnV0ZSBjYWNoZVxuICBwcml2YXRlIGxhc3RSZXF1ZXN0VGltZTogbnVtYmVyID0gMFxuICBwcml2YXRlIG1pblJlcXVlc3RJbnRlcnZhbDogbnVtYmVyID0gMjAwMCAvLyAyIHNlY29uZHMgYmV0d2VlbiByZXF1ZXN0c1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYXBpS2V5ID0gcHJvY2Vzcy5lbnYuQklOQU5DRV9BUElfS0VZIHx8ICcnXG4gICAgdGhpcy5zZWNyZXRLZXkgPSBwcm9jZXNzLmVudi5CSU5BTkNFX0FQSV9TRUNSRVQgfHwgJydcbiAgICB0aGlzLmJhc2VVUkwgPSBcImh0dHBzOi8vYXBpLmJpbmFuY2UuY29tXCJcbiAgICBcbiAgICAvLyBMb2cgQVBJIGtleSBzdGF0dXMgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnNvbGUubG9nKCdCaW5hbmNlIEFQSSBLZXkgc3RhdHVzOicsIHRoaXMuYXBpS2V5ID8gJ1ByZXNlbnQnIDogJ01pc3NpbmcnKVxuICAgIFxuICAgIC8vIERvbid0IHRocm93IGVycm9yLCB1c2UgZmFsbGJhY2sgaW5zdGVhZFxuICAgIGlmICghdGhpcy5hcGlLZXkpIHtcbiAgICAgIGNvbnNvbGUud2FybignQmluYW5jZSBBUEkga2V5IG5vdCBzZXQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLiBVc2luZyBmYWxsYmFjayBkYXRhLicpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVTaWduYXR1cmUocXVlcnlTdHJpbmc6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gVXNlIE5vZGUuanMgY3J5cHRvIGZvciBITUFDIFNIQTI1NlxuICAgIGNvbnN0IGNyeXB0byA9IGF3YWl0IGltcG9ydCgnY3J5cHRvJylcbiAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIHRoaXMuc2VjcmV0S2V5KVxuICAgICAgLnVwZGF0ZShxdWVyeVN0cmluZylcbiAgICAgIC5kaWdlc3QoJ2hleCcpXG4gIH1cblxuICBwcml2YXRlIGdldEhlYWRlcnMoaW5jbHVkZUF1dGg6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGNvbnN0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIH1cbiAgICBcbiAgICBpZiAoaW5jbHVkZUF1dGgpIHtcbiAgICAgIGhlYWRlcnNbJ1gtTUJYLUFQSUtFWSddID0gdGhpcy5hcGlLZXlcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIC8vIFJhdGUgbGltaXRpbmcgaGVscGVyXG4gIHByaXZhdGUgYXN5bmMgd2FpdEZvclJhdGVMaW1pdCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgdGltZVNpbmNlTGFzdFJlcXVlc3QgPSBub3cgLSB0aGlzLmxhc3RSZXF1ZXN0VGltZVxuICAgIFxuICAgIGlmICh0aW1lU2luY2VMYXN0UmVxdWVzdCA8IHRoaXMubWluUmVxdWVzdEludGVydmFsKSB7XG4gICAgICBjb25zdCB3YWl0VGltZSA9IHRoaXMubWluUmVxdWVzdEludGVydmFsIC0gdGltZVNpbmNlTGFzdFJlcXVlc3RcbiAgICAgIGNvbnNvbGUubG9nKGBSYXRlIGxpbWl0aW5nOiB3YWl0aW5nICR7d2FpdFRpbWV9bXNgKVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHdhaXRUaW1lKSlcbiAgICB9XG4gICAgXG4gICAgdGhpcy5sYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpXG4gIH1cblxuICAvLyBDaGVjayBpZiBjYWNoZWQgZGF0YSBpcyBzdGlsbCB2YWxpZFxuICBwcml2YXRlIGlzQ2FjaGVWYWxpZCgpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMucHJpY2VDYWNoZSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuICAgIHJldHVybiAobm93IC0gdGhpcy5wcmljZUNhY2hlLnRpbWVzdGFtcCkgPCB0aGlzLmNhY2hlVGltZW91dFxuICB9XG5cbiAgLy8gR2V0IGxpdmUgY3J5cHRvIHByaWNlcyB3aXRoIGNhY2hpbmcgYW5kIHJhdGUgbGltaXRpbmdcbiAgYXN5bmMgZ2V0Q3J5cHRvUHJpY2VzKCk6IFByb21pc2U8YW55W10+IHtcbiAgICAvLyBSZXR1cm4gY2FjaGVkIGRhdGEgaWYgc3RpbGwgdmFsaWRcbiAgICBpZiAodGhpcy5pc0NhY2hlVmFsaWQoKSkge1xuICAgICAgY29uc29sZS5sb2coJ1JldHVybmluZyBjYWNoZWQgcHJpY2UgZGF0YScpXG4gICAgICByZXR1cm4gdGhpcy5wcmljZUNhY2hlIS5kYXRhXG4gICAgfVxuXG4gICAgLy8gSWYgQVBJIGtleSBpcyBtaXNzaW5nLCBnbyBkaXJlY3RseSB0byBhbHRlcm5hdGl2ZSBzb3VyY2VcbiAgICBpZiAoIXRoaXMuYXBpS2V5KSB7XG4gICAgICBjb25zb2xlLmxvZygnTm8gQmluYW5jZSBBUEkga2V5IGF2YWlsYWJsZSwgdXNpbmcgYWx0ZXJuYXRpdmUgc291cmNlJylcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEFsdGVybmF0aXZlUHJpY2VzKClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgdHJ5IEJpbmFuY2VcbiAgICAgIGNvbnN0IHN5bWJvbHMgPSBbJ0JUQ1VTRFQnLCAnRVRIVVNEVCcsICdTT0xVU0RUJywgJ0RPR0VVU0RUJ11cbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBwcmljZXMgZnJvbSBCaW5hbmNlIEFQSS4uLicpXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdjMvdGlja2VyL3ByaWNlYCwge1xuICAgICAgICBoZWFkZXJzOiB0aGlzLmdldEhlYWRlcnModHJ1ZSkgLy8gSW5jbHVkZSBBUEkga2V5IGluIGhlYWRlcnNcbiAgICAgIH0pXG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdCaW5hbmNlIEFQSSByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0NTEgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0JpbmFuY2UgQVBJIHJlc3RyaWN0ZWQgb3IgdW5hdXRob3JpemVkLCB1c2luZyBhbHRlcm5hdGl2ZSBzb3VyY2UnKVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRBbHRlcm5hdGl2ZVByaWNlcygpXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQmluYW5jZSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEFsdGVybmF0aXZlUHJpY2VzKClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgYWxsUHJpY2VzOiBCaW5hbmNlVGlja2VyUHJpY2VbXSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIHByaWNlcyBmcm9tIEJpbmFuY2U6JywgYWxsUHJpY2VzLmxlbmd0aClcbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIGZvciBvdXIgc3VwcG9ydGVkIGNyeXB0b3MgYW5kIGNvbnZlcnQgdG8gb3VyIGZvcm1hdFxuICAgICAgY29uc3QgY3J5cHRvUHJpY2VzID0gc3ltYm9scy5tYXAoc3ltYm9sID0+IHtcbiAgICAgICAgY29uc3QgcHJpY2UgPSBhbGxQcmljZXMuZmluZChwID0+IHAuc3ltYm9sID09PSBzeW1ib2wpXG4gICAgICAgIGNvbnN0IGJhc2VBc3NldCA9IHN5bWJvbC5yZXBsYWNlKCdVU0RUJywgJycpXG4gICAgICAgIFxuICAgICAgICBpZiAoIXByaWNlKSByZXR1cm4gbnVsbFxuICAgICAgICBcbiAgICAgICAgY29uc3QgdXNkUHJpY2UgPSBwYXJzZUZsb2F0KHByaWNlLnByaWNlKVxuICAgICAgICBjb25zdCBpbnJQcmljZSA9IHVzZFByaWNlICogODMuNSAvLyBVU0QgdG8gSU5SIGNvbnZlcnNpb25cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3ltYm9sOiBiYXNlQXNzZXQsXG4gICAgICAgICAgbmFtZTogdGhpcy5nZXRDcnlwdG9OYW1lKGJhc2VBc3NldCksXG4gICAgICAgICAgcHJpY2VfdXNkOiB1c2RQcmljZSxcbiAgICAgICAgICBwcmljZV9pbnI6IGluclByaWNlLFxuICAgICAgICAgIGNoYW5nZV8yNGg6IDAsIC8vIFdlJ2xsIGdldCB0aGlzIGZyb20gMjRociB0aWNrZXJcbiAgICAgICAgICBpY29uOiB0aGlzLmdldENyeXB0b0ljb24oYmFzZUFzc2V0KSxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHNvdXJjZTogJ2JpbmFuY2UnXG4gICAgICAgIH1cbiAgICAgIH0pLmZpbHRlcihCb29sZWFuKVxuICAgICAgXG4gICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0XG4gICAgICB0aGlzLnByaWNlQ2FjaGUgPSB7XG4gICAgICAgIGRhdGE6IGNyeXB0b1ByaWNlcyxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBzb3VyY2U6ICdiaW5hbmNlJ1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gY3J5cHRvUHJpY2VzXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIEJpbmFuY2UgcHJpY2VzOicsIGVycm9yKVxuICAgICAgLy8gVHJ5IGFsdGVybmF0aXZlIEFQSVxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QWx0ZXJuYXRpdmVQcmljZXMoKVxuICAgIH1cbiAgfVxuXG4gIC8vIEFsdGVybmF0aXZlIHByaWNlIHNvdXJjZSB3aXRoIHJhdGUgbGltaXRpbmcgYW5kIGJldHRlciBlcnJvciBoYW5kbGluZ1xuICBwcml2YXRlIGFzeW5jIGdldEFsdGVybmF0aXZlUHJpY2VzKCk6IFByb21pc2U8YW55W10+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQXBwbHkgcmF0ZSBsaW1pdGluZ1xuICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yUmF0ZUxpbWl0KClcbiAgICAgIFxuICAgICAgY29uc3QgY29pbklkcyA9ICdiaXRjb2luLGV0aGVyZXVtLHRldGhlcixzb2xhbmEsZG9nZWNvaW4nXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgaHR0cHM6Ly9hcGkuY29pbmdlY2tvLmNvbS9hcGkvdjMvc2ltcGxlL3ByaWNlP2lkcz0ke2NvaW5JZHN9JnZzX2N1cnJlbmNpZXM9dXNkLGluciZpbmNsdWRlXzI0aHJfY2hhbmdlPXRydWVgLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdVc2VyLUFnZW50JzogJ0NyeXB0b1BheW1lbnRHYXRld2F5LzEuMCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb2luR2Vja28gQVBJIHJhdGUgbGltaXRlZCwgdXNpbmcgY2FjaGVkIG9yIGZhbGxiYWNrIGRhdGEnKVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGNhY2hlZCBkYXRhLCByZXR1cm4gaXQgZXZlbiBpZiBleHBpcmVkXG4gICAgICAgIGlmICh0aGlzLnByaWNlQ2FjaGUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmV0dXJuaW5nIGV4cGlyZWQgY2FjaGVkIGRhdGEgZHVlIHRvIHJhdGUgbGltaXQnKVxuICAgICAgICAgIHJldHVybiB0aGlzLnByaWNlQ2FjaGUuZGF0YVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSB1c2UgZmFsbGJhY2tcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmFsbGJhY2tQcmljZXMoKVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29pbkdlY2tvIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgXG4gICAgICBjb25zdCBjcnlwdG9QcmljZXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBzeW1ib2w6ICdCVEMnLFxuICAgICAgICAgIG5hbWU6ICdCaXRjb2luJyxcbiAgICAgICAgICBwcmljZV91c2Q6IGRhdGEuYml0Y29pbj8udXNkIHx8IDQyMDAwLFxuICAgICAgICAgIHByaWNlX2lucjogZGF0YS5iaXRjb2luPy5pbnIgfHwgMzUwNzAwMCxcbiAgICAgICAgICBjaGFuZ2VfMjRoOiBkYXRhLmJpdGNvaW4/LnVzZF8yNGhfY2hhbmdlIHx8IDAsXG4gICAgICAgICAgaWNvbjogJ+KCvycsXG4gICAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBzb3VyY2U6ICdjb2luZ2Vja28nXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzeW1ib2w6ICdFVEgnLFxuICAgICAgICAgIG5hbWU6ICdFdGhlcmV1bScsXG4gICAgICAgICAgcHJpY2VfdXNkOiBkYXRhLmV0aGVyZXVtPy51c2QgfHwgMzIwMCxcbiAgICAgICAgICBwcmljZV9pbnI6IGRhdGEuZXRoZXJldW0/LmluciB8fCAyNjcyMDAsXG4gICAgICAgICAgY2hhbmdlXzI0aDogZGF0YS5ldGhlcmV1bT8udXNkXzI0aF9jaGFuZ2UgfHwgMCxcbiAgICAgICAgICBpY29uOiAnzp4nLFxuICAgICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgc291cmNlOiAnY29pbmdlY2tvJ1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc3ltYm9sOiAnVVNEVCcsXG4gICAgICAgICAgbmFtZTogJ1RldGhlcicsXG4gICAgICAgICAgcHJpY2VfdXNkOiBkYXRhLnRldGhlcj8udXNkIHx8IDEuMCxcbiAgICAgICAgICBwcmljZV9pbnI6IGRhdGEudGV0aGVyPy5pbnIgfHwgODMuNSxcbiAgICAgICAgICBjaGFuZ2VfMjRoOiBkYXRhLnRldGhlcj8udXNkXzI0aF9jaGFuZ2UgfHwgMCxcbiAgICAgICAgICBpY29uOiAn4oKuJyxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHNvdXJjZTogJ2NvaW5nZWNrbydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHN5bWJvbDogJ1NPTCcsXG4gICAgICAgICAgbmFtZTogJ1NvbGFuYScsXG4gICAgICAgICAgcHJpY2VfdXNkOiBkYXRhLnNvbGFuYT8udXNkIHx8IDE3MC4wLFxuICAgICAgICAgIHByaWNlX2lucjogZGF0YS5zb2xhbmE/LmluciB8fCAxNDE5NS4wLFxuICAgICAgICAgIGNoYW5nZV8yNGg6IGRhdGEuc29sYW5hPy51c2RfMjRoX2NoYW5nZSB8fCAwLFxuICAgICAgICAgIGljb246ICdTJyxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHNvdXJjZTogJ2NvaW5nZWNrbydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHN5bWJvbDogJ0RPR0UnLFxuICAgICAgICAgIG5hbWU6ICdEb2dlY29pbicsXG4gICAgICAgICAgcHJpY2VfdXNkOiBkYXRhLmRvZ2Vjb2luPy51c2QgfHwgMC4xNixcbiAgICAgICAgICBwcmljZV9pbnI6IGRhdGEuZG9nZWNvaW4/LmluciB8fCAxMy4zNixcbiAgICAgICAgICBjaGFuZ2VfMjRoOiBkYXRhLmRvZ2Vjb2luPy51c2RfMjRoX2NoYW5nZSB8fCAwLFxuICAgICAgICAgIGljb246ICdEJyxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHNvdXJjZTogJ2NvaW5nZWNrbydcbiAgICAgICAgfVxuICAgICAgXVxuICAgICAgXG4gICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0XG4gICAgICB0aGlzLnByaWNlQ2FjaGUgPSB7XG4gICAgICAgIGRhdGE6IGNyeXB0b1ByaWNlcyxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBzb3VyY2U6ICdjb2luZ2Vja28nXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBjcnlwdG9QcmljZXNcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYWx0ZXJuYXRpdmUgcHJpY2VzOicsIGVycm9yKVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSBoYXZlIGNhY2hlZCBkYXRhLCByZXR1cm4gaXQgZXZlbiBpZiBleHBpcmVkXG4gICAgICBpZiAodGhpcy5wcmljZUNhY2hlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXR1cm5pbmcgZXhwaXJlZCBjYWNoZWQgZGF0YSBkdWUgdG8gQVBJIGVycm9yJylcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpY2VDYWNoZS5kYXRhLm1hcChpdGVtID0+ICh7XG4gICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICBzb3VyY2U6ICdjYWNoZWQnXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGaW5hbCBmYWxsYmFjayB0byBtb2NrIGRhdGEgd2l0aCBjdXJyZW50IHRpbWVzdGFtcFxuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmFsbGJhY2tQcmljZXMoKVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCAyNGhyIHByaWNlIGNoYW5nZSBzdGF0aXN0aWNzIHdpdGggcHJvcGVyIGVycm9yIGhhbmRsaW5nXG4gIGFzeW5jIGdldDI0aHJTdGF0cygpOiBQcm9taXNlPGFueVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN5bWJvbHMgPSBbJ0JUQ1VTRFQnLCAnRVRIVVNEVCcsICdTT0xVU0RUJywgJ0RPR0VVU0RUJ11cbiAgICAgIGNvbnN0IHByb21pc2VzID0gc3ltYm9scy5tYXAoc3ltYm9sID0+IFxuICAgICAgICBmZXRjaChgJHt0aGlzLmJhc2VVUkx9L2FwaS92My90aWNrZXIvMjRocj9zeW1ib2w9JHtzeW1ib2x9YCwge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpXG4gICAgICAgIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQ1MSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkgcmVzdHJpY3RlZCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIGZldGNoIDI0aHIgc3RhdHMgZm9yICR7c3ltYm9sfTpgLCBlcnJvci5tZXNzYWdlKVxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgXG4gICAgICAvLyBGaWx0ZXIgb3V0IG51bGwgcmVzcG9uc2VzIGFuZCBwcm9jZXNzIHZhbGlkIG9uZXNcbiAgICAgIGNvbnN0IHN0YXRzID0gcmVzcG9uc2VzXG4gICAgICAgIC5maWx0ZXIocmVzcG9uc2UgPT4gcmVzcG9uc2UgIT09IG51bGwgJiYgcmVzcG9uc2Uuc3ltYm9sKVxuICAgICAgICAubWFwKHN0YXQgPT4gKHtcbiAgICAgICAgICBzeW1ib2w6IHN0YXQuc3ltYm9sLnJlcGxhY2UoJ1VTRFQnLCAnJyksXG4gICAgICAgICAgcHJpY2VDaGFuZ2U6IHBhcnNlRmxvYXQoc3RhdC5wcmljZUNoYW5nZSB8fCAnMCcpLFxuICAgICAgICAgIHByaWNlQ2hhbmdlUGVyY2VudDogcGFyc2VGbG9hdChzdGF0LnByaWNlQ2hhbmdlUGVyY2VudCB8fCAnMCcpLFxuICAgICAgICAgIGxhc3RQcmljZTogcGFyc2VGbG9hdChzdGF0Lmxhc3RQcmljZSB8fCAnMCcpLFxuICAgICAgICAgIHZvbHVtZTogcGFyc2VGbG9hdChzdGF0LnZvbHVtZSB8fCAnMCcpXG4gICAgICAgIH0pKVxuICAgICAgXG4gICAgICByZXR1cm4gc3RhdHNcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgMjRociBzdGF0czonLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBhY2NvdW50IGJhbGFuY2VzIHdpdGggZmFsbGJhY2sgdG8gbW9jayBkYXRhXG4gIC8qXG4gIGFzeW5jIGdldFdhbGxldEJhbGFuY2VzKCk6IFByb21pc2U8YW55PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KClcbiAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gYHRpbWVzdGFtcD0ke3RpbWVzdGFtcH1gXG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLmNyZWF0ZVNpZ25hdHVyZShxdWVyeVN0cmluZylcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYCR7dGhpcy5iYXNlVVJMfS9hcGkvdjMvYWNjb3VudD8ke3F1ZXJ5U3RyaW5nfSZzaWduYXR1cmU9JHtzaWduYXR1cmV9YCxcbiAgICAgICAge1xuICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycyh0cnVlKVxuICAgICAgICB9XG4gICAgICApXG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQ1MSkge1xuICAgICAgICBjb25zb2xlLmxvZygnQmluYW5jZSBBUEkgcmVzdHJpY3RlZCBmb3Igd2FsbGV0IGJhbGFuY2VzLCB1c2luZyBtb2NrIGRhdGEnKVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb2NrV2FsbGV0QmFsYW5jZXMoKVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQmluYW5jZSBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGFjY291bnRJbmZvOiBCaW5hbmNlQWNjb3VudEluZm8gPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIFxuICAgICAgLy8gRmlsdGVyIGFuZCBmb3JtYXQgYmFsYW5jZXNcbiAgICAgIGNvbnN0IHJlbGV2YW50QXNzZXRzID0gWydCVEMnLCAnRVRIJywgJ1VTRFQnLCAnVVNEQycsICdCTkInXVxuICAgICAgY29uc3QgYmFsYW5jZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fVxuICAgICAgXG4gICAgICBhY2NvdW50SW5mby5iYWxhbmNlcy5mb3JFYWNoKGJhbGFuY2UgPT4ge1xuICAgICAgICBpZiAocmVsZXZhbnRBc3NldHMuaW5jbHVkZXMoYmFsYW5jZS5hc3NldCkpIHtcbiAgICAgICAgICBjb25zdCB0b3RhbCA9IHBhcnNlRmxvYXQoYmFsYW5jZS5mcmVlKSArIHBhcnNlRmxvYXQoYmFsYW5jZS5sb2NrZWQpXG4gICAgICAgICAgaWYgKHRvdGFsID4gMCkge1xuICAgICAgICAgICAgYmFsYW5jZXNbYmFsYW5jZS5hc3NldF0gPSB0b3RhbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgcmV0dXJuIGJhbGFuY2VzXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHdhbGxldCBiYWxhbmNlczonLCBlcnJvcilcbiAgICAgIHJldHVybiB0aGlzLmdldE1vY2tXYWxsZXRCYWxhbmNlcygpXG4gICAgfVxuICB9XG4gICovXG5cbiAgLy8gTW9jayB3YWxsZXQgYmFsYW5jZXMgZm9yIGRlbW8gcHVycG9zZXNcbiAgcHJpdmF0ZSBnZXRNb2NrV2FsbGV0QmFsYW5jZXMoKTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIEJUQzogMC4xNTQzMixcbiAgICAgIEVUSDogMi44NzY1LFxuICAgICAgVVNEVDogMTI1MC41MCxcbiAgICAgIFVTREM6IDUwMC4wMCxcbiAgICAgIEJOQjogMTIuMzQ1LFxuICAgICAgU09MOiAyNS43NSxcbiAgICAgIERPR0U6IDUwMDAuMDBcbiAgICB9XG4gIH1cblxuICAvLyBDb252ZXJ0IGZpYXQgdG8gY3J5cHRvIGFtb3VudFxuICBhc3luYyBjb252ZXJ0RmlhdFRvQ3J5cHRvKGZpYXRBbW91bnQ6IG51bWJlciwgZmlhdEN1cnJlbmN5OiBzdHJpbmcsIGNyeXB0b1N5bWJvbDogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJpY2VzID0gYXdhaXQgdGhpcy5nZXRDcnlwdG9QcmljZXMoKVxuICAgICAgY29uc3QgY3J5cHRvID0gcHJpY2VzLmZpbmQocCA9PiBwLnN5bWJvbCA9PT0gY3J5cHRvU3ltYm9sKVxuICAgICAgXG4gICAgICBpZiAoIWNyeXB0bykgcmV0dXJuIDBcbiAgICAgIFxuICAgICAgbGV0IGNyeXB0b1ByaWNlID0gMFxuICAgICAgaWYgKGZpYXRDdXJyZW5jeSA9PT0gJ1VTRCcpIHtcbiAgICAgICAgY3J5cHRvUHJpY2UgPSBjcnlwdG8ucHJpY2VfdXNkXG4gICAgICB9IGVsc2UgaWYgKGZpYXRDdXJyZW5jeSA9PT0gJ0lOUicpIHtcbiAgICAgICAgY3J5cHRvUHJpY2UgPSBjcnlwdG8ucHJpY2VfaW5yXG4gICAgICB9IGVsc2UgaWYgKGZpYXRDdXJyZW5jeSA9PT0gJ0VVUicpIHtcbiAgICAgICAgY3J5cHRvUHJpY2UgPSBjcnlwdG8ucHJpY2VfdXNkICogMC44NVxuICAgICAgfSBlbHNlIGlmIChmaWF0Q3VycmVuY3kgPT09ICdHQlAnKSB7XG4gICAgICAgIGNyeXB0b1ByaWNlID0gY3J5cHRvLnByaWNlX3VzZCAqIDAuNzVcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZpYXRBbW91bnQgLyBjcnlwdG9QcmljZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb252ZXJ0aW5nIGZpYXQgdG8gY3J5cHRvOicsIGVycm9yKVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gIH1cblxuICAvLyBDb252ZXJ0IGNyeXB0byB0byBmaWF0IGFtb3VudFxuICBhc3luYyBjb252ZXJ0Q3J5cHRvVG9GaWF0KGNyeXB0b0Ftb3VudDogbnVtYmVyLCBjcnlwdG9TeW1ib2w6IHN0cmluZywgZmlhdEN1cnJlbmN5OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcmljZXMgPSBhd2FpdCB0aGlzLmdldENyeXB0b1ByaWNlcygpXG4gICAgICBjb25zdCBjcnlwdG8gPSBwcmljZXMuZmluZChwID0+IHAuc3ltYm9sID09PSBjcnlwdG9TeW1ib2wpXG4gICAgICBcbiAgICAgIGlmICghY3J5cHRvKSByZXR1cm4gMFxuICAgICAgXG4gICAgICBsZXQgY3J5cHRvUHJpY2UgPSAwXG4gICAgICBpZiAoZmlhdEN1cnJlbmN5ID09PSAnVVNEJykge1xuICAgICAgICBjcnlwdG9QcmljZSA9IGNyeXB0by5wcmljZV91c2RcbiAgICAgIH0gZWxzZSBpZiAoZmlhdEN1cnJlbmN5ID09PSAnSU5SJykge1xuICAgICAgICBjcnlwdG9QcmljZSA9IGNyeXB0by5wcmljZV9pbnJcbiAgICAgIH0gZWxzZSBpZiAoZmlhdEN1cnJlbmN5ID09PSAnRVVSJykge1xuICAgICAgICBjcnlwdG9QcmljZSA9IGNyeXB0by5wcmljZV91c2QgKiAwLjg1XG4gICAgICB9IGVsc2UgaWYgKGZpYXRDdXJyZW5jeSA9PT0gJ0dCUCcpIHtcbiAgICAgICAgY3J5cHRvUHJpY2UgPSBjcnlwdG8ucHJpY2VfdXNkICogMC43NVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gY3J5cHRvQW1vdW50ICogY3J5cHRvUHJpY2VcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29udmVydGluZyBjcnlwdG8gdG8gZmlhdDonLCBlcnJvcilcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgY3J5cHRvIGFkZHJlc3MgKG1vY2sgLSBpbiBwcm9kdWN0aW9uIHVzZSBwcm9wZXIgd2FsbGV0IGdlbmVyYXRpb24pXG4gIGdlbmVyYXRlQ3J5cHRvQWRkcmVzcyhzeW1ib2w6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgcHJlZml4ZXMgPSB7XG4gICAgICBCVEM6ICcxJyxcbiAgICAgIEVUSDogJzB4JyxcbiAgICAgIFVTRFQ6ICcweCcsXG4gICAgICBVU0RDOiAnMHgnLFxuICAgICAgQk5COiAnYm5iJyxcbiAgICAgIFNPTDogJ3NvbCcsXG4gICAgICBET0dFOiAnRCdcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcHJlZml4ID0gcHJlZml4ZXNbc3ltYm9sIGFzIGtleW9mIHR5cGVvZiBwcmVmaXhlc10gfHwgJzB4J1xuICAgIGNvbnN0IHJhbmRvbUhleCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygyLCAzNClcbiAgICByZXR1cm4gcHJlZml4ICsgcmFuZG9tSGV4XG4gIH1cblxuICAvLyBTaW11bGF0ZSBvbi1jaGFpbiB0cmFuc2ZlciAoaW4gcHJvZHVjdGlvbiwgdXNlIHByb3BlciBibG9ja2NoYWluIGludGVncmF0aW9uKVxuICBhc3luYyBzaW11bGF0ZVRyYW5zZmVyKGZyb21BZGRyZXNzOiBzdHJpbmcsIHRvQWRkcmVzczogc3RyaW5nLCBhbW91bnQ6IG51bWJlciwgc3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIC8vIFNpbXVsYXRlIG5ldHdvcmsgZGVsYXlcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpXG4gICAgXG4gICAgLy8gR2VuZXJhdGUgdHJhbnNhY3Rpb24gaGFzaFxuICAgIGNvbnN0IHR4SGFzaCA9ICcweCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMiwgNjYpXG4gICAgXG4gICAgY29uc29sZS5sb2coYFNpbXVsYXRlZCAke3N5bWJvbH0gdHJhbnNmZXI6YClcbiAgICBjb25zb2xlLmxvZyhgRnJvbTogJHtmcm9tQWRkcmVzc31gKVxuICAgIGNvbnNvbGUubG9nKGBUbzogJHt0b0FkZHJlc3N9YClcbiAgICBjb25zb2xlLmxvZyhgQW1vdW50OiAke2Ftb3VudH0gJHtzeW1ib2x9YClcbiAgICBjb25zb2xlLmxvZyhgVFggSGFzaDogJHt0eEhhc2h9YClcbiAgICBcbiAgICByZXR1cm4gdHhIYXNoXG4gIH1cblxuICBwcml2YXRlIGdldENyeXB0b05hbWUoc3ltYm9sOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IG5hbWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgQlRDOiAnQml0Y29pbicsXG4gICAgICBFVEg6ICdFdGhlcmV1bScsXG4gICAgICBVU0RUOiAnVGV0aGVyJyxcbiAgICAgIFVTREM6ICdVU0QgQ29pbicsXG4gICAgICBCTkI6ICdCaW5hbmNlIENvaW4nLFxuICAgICAgU09MOiAnU29sYW5hJyxcbiAgICAgIERPR0U6ICdEb2dlY29pbidcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzW3N5bWJvbF0gfHwgc3ltYm9sXG4gIH1cblxuICBwcml2YXRlIGdldENyeXB0b0ljb24oc3ltYm9sOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGljb25zOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgQlRDOiAn4oK/JyxcbiAgICAgIEVUSDogJ86eJyxcbiAgICAgIFVTRFQ6ICfigq4nLFxuICAgICAgVVNEQzogJyQnLFxuICAgICAgQk5COiAnQicsXG4gICAgICBTT0w6ICdTJyxcbiAgICAgIERPR0U6ICdEJ1xuICAgIH1cbiAgICByZXR1cm4gaWNvbnNbc3ltYm9sXSB8fCAn4oK/J1xuICB9XG5cbiAgLy8gRW5oYW5jZWQgZmFsbGJhY2sgcHJpY2VzIHdpdGggcmVhbGlzdGljIHZhcmlhdGlvbnNcbiAgcHJpdmF0ZSBnZXRGYWxsYmFja1ByaWNlcygpIHtcbiAgICAvLyBBZGQgc29tZSByZWFsaXN0aWMgcHJpY2UgdmFyaWF0aW9uc1xuICAgIGNvbnN0IGJ0Y0Jhc2UgPSA0MjAwMFxuICAgIGNvbnN0IGV0aEJhc2UgPSAzMjAwXG4gICAgY29uc3QgdXNkdEJhc2UgPSAxLjBcbiAgICBjb25zdCBzb2xCYXNlID0gMTcwLjBcbiAgICBjb25zdCBkb2dlQmFzZSA9IDAuMTZcbiAgICBcbiAgICBjb25zdCB2YXJpYXRpb24gPSAoKSA9PiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAyIC8vIMKxMSUgdmFyaWF0aW9uXG4gICAgXG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgc3ltYm9sOiAnQlRDJyxcbiAgICAgICAgbmFtZTogJ0JpdGNvaW4nLFxuICAgICAgICBwcmljZV91c2Q6IGJ0Y0Jhc2UgKiAoMSArIHZhcmlhdGlvbigpKSxcbiAgICAgICAgcHJpY2VfaW5yOiBidGNCYXNlICogODMuNSAqICgxICsgdmFyaWF0aW9uKCkpLFxuICAgICAgICBjaGFuZ2VfMjRoOiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxMCwgLy8gwrE1JSBjaGFuZ2VcbiAgICAgICAgaWNvbjogJ+KCvycsXG4gICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHNvdXJjZTogJ2ZhbGxiYWNrJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3ltYm9sOiAnRVRIJyxcbiAgICAgICAgbmFtZTogJ0V0aGVyZXVtJyxcbiAgICAgICAgcHJpY2VfdXNkOiBldGhCYXNlICogKDEgKyB2YXJpYXRpb24oKSksXG4gICAgICAgIHByaWNlX2lucjogZXRoQmFzZSAqIDgzLjUgKiAoMSArIHZhcmlhdGlvbigpKSxcbiAgICAgICAgY2hhbmdlXzI0aDogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogOCwgLy8gwrE0JSBjaGFuZ2VcbiAgICAgICAgaWNvbjogJ86eJyxcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgc291cmNlOiAnZmFsbGJhY2snXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzeW1ib2w6ICdVU0RUJyxcbiAgICAgICAgbmFtZTogJ1RldGhlcicsXG4gICAgICAgIHByaWNlX3VzZDogdXNkdEJhc2UgKiAoMSArIHZhcmlhdGlvbigpICogMC4xKSwgLy8gU21hbGxlciB2YXJpYXRpb24gZm9yIHN0YWJsZWNvaW5cbiAgICAgICAgcHJpY2VfaW5yOiB1c2R0QmFzZSAqIDgzLjUgKiAoMSArIHZhcmlhdGlvbigpICogMC4xKSxcbiAgICAgICAgY2hhbmdlXzI0aDogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC41LCAvLyDCsTAuMjUlIGNoYW5nZVxuICAgICAgICBpY29uOiAn4oKuJyxcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgc291cmNlOiAnZmFsbGJhY2snXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzeW1ib2w6ICdTT0wnLFxuICAgICAgICBuYW1lOiAnU29sYW5hJyxcbiAgICAgICAgcHJpY2VfdXNkOiBzb2xCYXNlICogKDEgKyB2YXJpYXRpb24oKSksXG4gICAgICAgIHByaWNlX2lucjogc29sQmFzZSAqIDgzLjUgKiAoMSArIHZhcmlhdGlvbigpKSxcbiAgICAgICAgY2hhbmdlXzI0aDogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogOSwgLy8gwrE0LjUlIGNoYW5nZVxuICAgICAgICBpY29uOiAnUycsXG4gICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHNvdXJjZTogJ2ZhbGxiYWNrJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc3ltYm9sOiAnRE9HRScsXG4gICAgICAgIG5hbWU6ICdEb2dlY29pbicsXG4gICAgICAgIHByaWNlX3VzZDogZG9nZUJhc2UgKiAoMSArIHZhcmlhdGlvbigpKSxcbiAgICAgICAgcHJpY2VfaW5yOiBkb2dlQmFzZSAqIDgzLjUgKiAoMSArIHZhcmlhdGlvbigpKSxcbiAgICAgICAgY2hhbmdlXzI0aDogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMTIsIC8vIMKxNiUgY2hhbmdlXG4gICAgICAgIGljb246ICdEJyxcbiAgICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgc291cmNlOiAnZmFsbGJhY2snXG4gICAgICB9XG4gICAgXVxuICB9XG5cbiAgLy8gQ2xlYXIgY2FjaGUgbWFudWFsbHkgaWYgbmVlZGVkXG4gIGNsZWFyQ2FjaGUoKTogdm9pZCB7XG4gICAgdGhpcy5wcmljZUNhY2hlID0gbnVsbFxuICAgIGNvbnNvbGUubG9nKCdQcmljZSBjYWNoZSBjbGVhcmVkJylcbiAgfVxuXG4gIC8vIEdldCBjYWNoZSBzdGF0dXNcbiAgZ2V0Q2FjaGVTdGF0dXMoKTogeyBjYWNoZWQ6IGJvb2xlYW4sIGFnZTogbnVtYmVyLCBzb3VyY2U6IHN0cmluZyB9IHtcbiAgICBpZiAoIXRoaXMucHJpY2VDYWNoZSkge1xuICAgICAgcmV0dXJuIHsgY2FjaGVkOiBmYWxzZSwgYWdlOiAwLCBzb3VyY2U6ICdub25lJyB9XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGFnZSA9IERhdGUubm93KCkgLSB0aGlzLnByaWNlQ2FjaGUudGltZXN0YW1wXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhY2hlZDogdHJ1ZSxcbiAgICAgIGFnZSxcbiAgICAgIHNvdXJjZTogdGhpcy5wcmljZUNhY2hlLnNvdXJjZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYmluYW5jZUFQSSA9IG5ldyBCaW5hbmNlQVBJKClcbiJdLCJuYW1lcyI6WyJCaW5hbmNlQVBJIiwiY29uc3RydWN0b3IiLCJwcmljZUNhY2hlIiwiY2FjaGVUaW1lb3V0IiwibGFzdFJlcXVlc3RUaW1lIiwibWluUmVxdWVzdEludGVydmFsIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIkJJTkFOQ0VfQVBJX0tFWSIsInNlY3JldEtleSIsIkJJTkFOQ0VfQVBJX1NFQ1JFVCIsImJhc2VVUkwiLCJjb25zb2xlIiwibG9nIiwid2FybiIsImNyZWF0ZVNpZ25hdHVyZSIsInF1ZXJ5U3RyaW5nIiwiY3J5cHRvIiwiY3JlYXRlSG1hYyIsInVwZGF0ZSIsImRpZ2VzdCIsImdldEhlYWRlcnMiLCJpbmNsdWRlQXV0aCIsImhlYWRlcnMiLCJ3YWl0Rm9yUmF0ZUxpbWl0Iiwibm93IiwiRGF0ZSIsInRpbWVTaW5jZUxhc3RSZXF1ZXN0Iiwid2FpdFRpbWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJpc0NhY2hlVmFsaWQiLCJ0aW1lc3RhbXAiLCJnZXRDcnlwdG9QcmljZXMiLCJkYXRhIiwiZ2V0QWx0ZXJuYXRpdmVQcmljZXMiLCJzeW1ib2xzIiwicmVzcG9uc2UiLCJmZXRjaCIsInN0YXR1cyIsIm9rIiwiZXJyb3IiLCJhbGxQcmljZXMiLCJqc29uIiwibGVuZ3RoIiwiY3J5cHRvUHJpY2VzIiwibWFwIiwic3ltYm9sIiwicHJpY2UiLCJmaW5kIiwicCIsImJhc2VBc3NldCIsInJlcGxhY2UiLCJ1c2RQcmljZSIsInBhcnNlRmxvYXQiLCJpbnJQcmljZSIsIm5hbWUiLCJnZXRDcnlwdG9OYW1lIiwicHJpY2VfdXNkIiwicHJpY2VfaW5yIiwiY2hhbmdlXzI0aCIsImljb24iLCJnZXRDcnlwdG9JY29uIiwibGFzdFVwZGF0ZWQiLCJ0b0lTT1N0cmluZyIsInNvdXJjZSIsImZpbHRlciIsIkJvb2xlYW4iLCJjb2luSWRzIiwiZ2V0RmFsbGJhY2tQcmljZXMiLCJFcnJvciIsImJpdGNvaW4iLCJ1c2QiLCJpbnIiLCJ1c2RfMjRoX2NoYW5nZSIsImV0aGVyZXVtIiwidGV0aGVyIiwic29sYW5hIiwiZG9nZWNvaW4iLCJpdGVtIiwiZ2V0MjRoclN0YXRzIiwicHJvbWlzZXMiLCJ0aGVuIiwiY2F0Y2giLCJtZXNzYWdlIiwicmVzcG9uc2VzIiwiYWxsIiwic3RhdHMiLCJzdGF0IiwicHJpY2VDaGFuZ2UiLCJwcmljZUNoYW5nZVBlcmNlbnQiLCJsYXN0UHJpY2UiLCJ2b2x1bWUiLCJnZXRNb2NrV2FsbGV0QmFsYW5jZXMiLCJCVEMiLCJFVEgiLCJVU0RUIiwiVVNEQyIsIkJOQiIsIlNPTCIsIkRPR0UiLCJjb252ZXJ0RmlhdFRvQ3J5cHRvIiwiZmlhdEFtb3VudCIsImZpYXRDdXJyZW5jeSIsImNyeXB0b1N5bWJvbCIsInByaWNlcyIsImNyeXB0b1ByaWNlIiwiY29udmVydENyeXB0b1RvRmlhdCIsImNyeXB0b0Ftb3VudCIsImdlbmVyYXRlQ3J5cHRvQWRkcmVzcyIsInByZWZpeGVzIiwicHJlZml4IiwicmFuZG9tSGV4IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwic2ltdWxhdGVUcmFuc2ZlciIsImZyb21BZGRyZXNzIiwidG9BZGRyZXNzIiwiYW1vdW50IiwidHhIYXNoIiwibmFtZXMiLCJpY29ucyIsImJ0Y0Jhc2UiLCJldGhCYXNlIiwidXNkdEJhc2UiLCJzb2xCYXNlIiwiZG9nZUJhc2UiLCJ2YXJpYXRpb24iLCJjbGVhckNhY2hlIiwiZ2V0Q2FjaGVTdGF0dXMiLCJjYWNoZWQiLCJhZ2UiLCJiaW5hbmNlQVBJIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./lib/binance-api.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fcrypto%2Flive-prices%2Froute&page=%2Fapi%2Fcrypto%2Flive-prices%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fcrypto%2Flive-prices%2Froute.ts&appDir=C%3A%5CUsers%5CAdmin%5CDesktop%5CZerokost%5CCryptopppp%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CAdmin%5CDesktop%5CZerokost%5CCryptopppp&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();